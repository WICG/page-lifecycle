<pre class='metadata'>
Title: Page Lifecycle
Group: webperf
Shortname: page-lifecycle
Level: 1
ED:
TR:
Status: ED
Editor: Shubhie Panicker, Google https://google.com, panicker@google.com
Editor: Domenic Denicola, Google https://google.com, d@domenic.me
Repository: wicg/page-lifecycle
Abstract: This document defines an API that supports browsers' ability to manage lifecycle of web pages.
Default Highlight: js
</pre>

<pre class='link-defaults'>
spec:dom; type:interface; text:Document
</pre>

<pre class='anchors'>
spec: HTML; urlPrefix: https://html.spec.whatwg.org/multipage/;
    type: attribute; text: persisted; for:PageTransitionEvent; url: browsing-the-web.html#dom-pagetransitionevent-persisted
    type: dfn; text: traverse the history; url: browsing-the-web.html#traverse-the-history
    type: dfn; text: list of the descendant browsing contexts; url: browsers.html#list-of-the-descendant-browsing-contexts
    type: dfn; text: browsing context; for: document; url: browsers.html#concept-document-bc
    type: dfn; text: readiness; for: document; url: dom.html#current-document-readiness
    type: dfn; text: iframe load in progress; url: iframe-embed-object.html#iframe-load-in-progress
    type: dfn; text: iframe load event steps; url: iframe-embed-object.html#iframe-load-event-steps
    type: dfn; text: Update the rendering; url: webappapis.html#update-the-rendering
    type: dfn; text: being rendered; url: rendering.html#being-rendered
    type: dfn; text: browsing context container; url: browsers.html#browsing-context-container
    type: dfn; text: media elements; url: media.html#media-element
    type: dfn; text: media-elements; url: media.html#media-elements
    type: dfn; text: dom-manipulation-task-source; url: webappapis.html#dom-manipulation-task-source
    type: dfn; text: user-interaction-task-source; url: webappapis.html#user-interaction-task-source
    type: dfn; text: networking-task-source; url: webappapis.html#networking-task-source
    type: dfn; text: history-traversal-task-source; url: webappapis.html#history-traversal-task-source
    type: dfn; text: embed-task-source; url: iframe-embed-object.html#embed-task-source
    type: dfn; text: media-element-event-task-source; url: media.html#media-element-event-task-source
    type: dfn; text: canvas-blob-serialisation-task-source; url: canvas.html#canvas-blob-serialisation-task-source
    type: dfn; text: microtask-task-source; url: webappapis.html#microtask-task-source
    type: dfn; text: timer-task-source; url: timers-and-user-prompts.html#timer-task-source
    type: dfn; text: remote-event-task-source; url: server-sent-events.html#remote-event-task-source
    type: dfn; text: websocket-task-source; url: web-sockets.html#websocket-task-source
    type: dfn; text: posted-message-task-source; url: web-messaging.html#posted-message-task-source
    type: dfn; text: unshipped-port-message-queue; url: web-messaging.html#unshipped-port-message-queue
</pre>

<pre class='anchors'>
spec: CSS2; urlPrefix: https://www.w3.org/TR/CSS2/
    type: dfn; text: viewport; url: visuren.html#viewport
</pre>

<pre class='anchors'>
spec: FileAPI; urlPrefix: https://www.w3.org/TR/FileAPI/
    type: dfn; text: fileReadingTaskSource; url: #blobreader-task-source
</pre>

<pre class='anchors'>
spec: IndexedDB; urlPrefix: https://www.w3.org/TR/IndexedDB/
    type: dfn; text: database-access-task-source; url: #database-access-task-source
</pre>

<pre class='anchors'>
spec: PresentationAPI; urlPrefix: https://w3c.github.io/presentation-api/
    type: dfn; text: presentation-task-source; url: #common-idioms
</pre>


<pre class='anchors'>
spec: IntersectionObserver; urlPrefix: https://w3c.github.io/IntersectionObserver/
    type: dfn; text: compute the intersection of a target element and the root; url: #calculate-intersection-rect-algo
</pre>

<pre class='anchors'>
spec: GenericSensor; urlPrefix: https://www.w3.org/TR/2016/WD-generic-sensor-20160830/
    type: dfn; text: sensor-task-source; url: #sensor-task-source
</pre>

<pre class='anchors'>
spec: PerformanceTimeline; urlPrefix: https://w3c.github.io/performance-timeline/
    type: dfn; text: performance-timeline-task-source; url: #queue-a-performanceentry
</pre>

<pre class='anchors'>
spec: WebGL; urlPrefix: https://www.khronos.org/registry/webgl/specs/latest/1.0/
    type: dfn; text: web-gl-task-source; url: #5.15
</pre>

<pre class='anchors'>
spec: RequestIdleCallback; urlPrefix: https://www.w3.org/TR/requestidlecallback/
    type: dfn; text: idle-task-task-source; url: #the-requestidlecallback-method
</pre>

<pre class='anchors'>
spec: CSSFontLoading; urlPrefix: https://drafts.csswg.org/css-font-loading/
    type: dfn; text: font-loading-task-source; url: #task-source
</pre>

<pre class='anchors'>
spec: Manifest; urlPrefix: https://w3c.github.io/manifest/
    type: dfn; text: application-life-cycle-task-source; url: #dfn-application-life-cycle-task-source
</pre>

<pre class='anchors'>
spec: BackgroundFetch; urlPrefix: https://wicg.github.io/background-fetch/
    type: dfn; text: background-fetch-task-source; url: #background-fetch-task-source
</pre>

<pre class='anchors'>
spec: Permissions; urlPrefix: https://www.w3.org/TR/permissions/
    type: dfn; text: permission-task-source; url: #permission-task-source
</pre>

<pre class='anchors'>
spec: ServiceWorker; urlPrefix: https://w3c.github.io/ServiceWorker/
    type: dfn; text: client-message-queue-task-source; url: #dfn-client-message-queue
</pre>


Introduction {#intro}
=====================
With large numbers of web apps (and tabs) running, critical resources such as memory, CPU, battery, network, etc. easily get oversubscribed, leading to a bad end-user experience. Application lifecycle is a key way that modern OSs manage resources.

For a platform to support application lifecycle, it needs to:
    * provide developers with signals about transitions between the lifecycle states
    * provide lifecycle-compatible APIs that allow key capabilities to work even when the app is backgrounded or stopped.

This proposal attempts to define what the lifecycle of a web page is and add needed extensions to enable web applications to respond to two important lifecycle events commonly performed by user agents:
    * Tab discarding (for memory saving)
    * CPU suspension (for battery, data, CPU saving)

Page Lifecycle States {#sec-lifecycle-states}
==============================

This spec defines what the lifecycle of a web page is and adds extensions to enable web applications to respond to two important lifecycle events commonly performed by user agents:
    * CPU suspension (for conserving battery, data, CPU)
    * Tab discarding (for memory saving)

This spec formalizes two new lifecycle states to support the above:
    * <dfn for="Lifecycle">Frozen</dfn>: lifecycle state for CPU suspension. This means that the [=freeze steps=] algorithm was called on the {{Document}}'s [=document/browsing context=]. Normally HIDDEN pages will be [=/frozen=] to conserve resources.
    * <dfn for="Lifecycle">Discarded</dfn>: means that the [=discard=] algorithm was called on the {{Document}}'s [=document/browsing context=]. Normally [=/frozen=] frames will be moved to [=Lifecycle/discarded=] state to conserve resources.

TODO(panicker): Insert diagram

API {#sec-api}
=======================================

Page Lifecycle involves the following additions:

<pre class="idl">
    partial interface Document {
        attribute EventHandler onfreeze;
        attribute EventHandler onresume;
        readonly attribute boolean wasDiscarded;
    };
</pre>

The <dfn attribute for="Document">onfreeze</dfn> and <dfn attribute for="Document">onresume</dfn> attributes are [=event handler IDL attributes=] for the <code>freeze</code> and <code>resume</code> events, respectively.

The <dfn attribute for="Document">wasDiscarded</dfn> attribute's getter must return the value of this {{Document}}'s [=Document/discarded=] boolean.

    NOTE: these APIs are added on {{Document}}, instead of on {{Window}}, for consistency with the Page Visibility API; we expect these APIs to be used in tandem with that existing one. [[PAGE-VISIBILITY]]

    NOTE: In addition <a href="https://github.com/whatwg/html/issues/3378"><code>clientId</code> and <code>discardedClientId</code></a> will be added to {{Window}}, to support restoring view state when user revisits a discarded page, causing a reload. We expect those to be used by code that reacts to these events.

Usage example {#example}
------------------------

Example of handling freeze and resume:
<pre class="example highlight">
const prepareForFreeze = () => {
  // Close any open IndexedDB connections.
  // Release any web locks.
  // Stop timers or polling.
};

const reInitializeApp = () => {
  // Restore IndexedDB connections.
  // Re-acquire any needed web locks.
  // Restart timers or polling.
};

document.addEventListener('freeze', prepareForFreeze);
document.addEventListener('resume', reInitializeApp);
</pre>

Example of restoring view state after discard:
A user could have multiple tabs open for the same app & URL. If they are both in the background and are both discarded, then the app would need to distinguish between the two tabs to restore the correct state. clientId and lastClientId on the Window can be used for this purpose.
<pre class="example highlight">
// Persists state to IndexedDB, making sure to set the current value of
// `self.clientId` on the record, so it can be retrieved later using
// `getPersistedState()` (if the tab has to be reloaded after a discard).
const persistState = async (state) => {
  const record = {...state, cliendId: self.clientId};

  // Persist record to IndexedDB or SessionStorage....
}

// Retrieves the state record from IndexedDB based on the passed client ID.
const getPersistedState = async (clientId) => {
  // Lookup record in IndexedDB...
};

// If the tab was previously discarded, get the persisted state for the
// client ID of the discarded tab via `self.lastClientId`.
if (document.wasDiscarded) {
  getPersistedState(self.lastClientId);
}
</pre>

Feature Policies {#feature-policies}
=====================
Controlling the execution state of [=nested browsing contexts=] is desirable from a [=document/browsing context=] in order to control
the user experience. An application may desire that when a document is not [=being rendered=] or does not intersect the [=viewport=]
that all execution stops in the [=nested browsing context=] (including currently playing video, audio). Stopping all execution
can lead to an improvement in CPU utilization. To meet these needs two feature policies are defined:
 * execution-while-not-rendered, which has a [=default allowlist=] of '*'
 * execution-while-out-of-viewport, which has a [=default allowlist=] of '*'

The <dfn export>execution-while-not-rendered</dfn> policy controls whether [=task source/freezable=]
tasks should execute for [=nested browsing contexts=] whose [=browsing context container=] is not [=being rendered=]. e.g. via `display: none`.

The <dfn export>execution-while-out-of-viewport</dfn> policy controls whether [=task source/freezable=]
tasks should execute for [=nested browsing contexts=] whose [=browsing context container=] does not intersect the [=viewport=] according
to [=compute the intersection of a target element and the root=].

Application of these policies is accomplished by placing the document (and its decendants) in a [=/frozen=] state when the following
conditions have been met:
 * [=iframe load event steps=] have been run
 * the policy is disabled for the document
 * relevant policy condition applies (not rendered or scrolled out of view)

If these conditions aren't met the document will be in the [=/unfrozen=] state.

<pre class="example highlight">

// The iframe will be frozen immediately after it is loaded.

&lt;iframe allow="execution-while-not-rendered 'none'"
  src="subframe.html" style="display:none"&gt;&lt;/iframe&gt;
</pre>

To run the <dfn export>update document frozenness steps</dfn> for a {{Document}} <var>document</var>,
run the following steps:
1. If <var>document</var>'s [=document/browsing context=] is not a [=nested browsing context=], return.
1. If <var>document</var>'s [=document/readiness=] is not "complete", return.
1. Let <var>element</var> be <var>document</var>'s [=nested browsing context=]'s [=browsing context container=].
1. Let <var>frozenness</var> be false.
1. Let <var>auto resume media</var> be false.
1. If <var>document</var> is not [=allowed to use=] the [=execution-while-not-rendered=] feature then:
    1. If <var>element</var> is not [=being rendered=],  set <var>frozenness</var>'s to <code>true</code>.
1. Otherwise if <var>document</var> is not [=allowed to use=] the [=execution-while-out-of-viewport=] feature then:
    1. If <var>element</var> does not intersect the [=viewport=] according to [=compute the intersection of a target element and the root=], set <var>frozenness</var> to <code>true</code>, <var>auto resume media</var> to <code>true</code>.
1. If <var>frozenness</var> does not equal <var>document</var>'s [=FROZENNESS=] state, execute [[#change-frozenness-of-document]] passing in |document|, |frozenness|, |auto resume media|.


Processing model {#sec-processing-model}
========================================

Modifications to the HTML Standard {#mod}
--------------------------------------------

### HTML: <a href="https://html.spec.whatwg.org/#task-source">task source</a> ### {#html-task-source-dfn}

Each task source is classified as <dfn for="task source">freezable</dfn> or <dfn for="task source">unfreezable</dfn>.

All tasks queued on [=task source/freezable=] task source are automatically freezable.

Examples of [=task source/freezable=] task sources are:

* timers: callbacks generated by timers of a Document
* networking: tasks queued due to loading of resources
* DOM manipulation, user interaction, history traversal etc.

<table><tbody>
<tr><th>Task Queue</th><th>Freezable</th></tr>
<tr><td>[=dom-manipulation-task-source=]</td><td>Yes</td></tr>
<tr><td>[=user-interaction-task-source=]</td><td>Yes</td></tr>
<tr><td>[=networking-task-source=]</td><td>Yes* (pending request inflight allowed)</td></tr>
<tr><td>[=history-traversal-task-source=]</td><td>Yes</td></tr>
<tr><td>[=embed-task-source=]</td><td>Yes</td></tr>
<tr><td>[=media-element-event-task-source=]</td><td>Yes</td></tr>
<tr><td>[=canvas-blob-serialisation-task-source=]</td><td>Yes</td></tr>
<tr><td>[=microtask-task-source=]</td><td>Yes</td></tr>
<tr><td>[=timer-task-source=]</td><td>Yes</td></tr>
<tr><td>[=remote-event-task-source=]</td><td>Yes</td></tr>
<tr><td>[=websocket-task-source=]</td><td>Yes</td></tr>
<tr><td>[=posted-message-task-source=]</td><td>Yes</td></tr>
<tr><td>[=unshipped-port-message-queue=]</td><td>Yes</td></tr>
<tr><td>[=fileReadingTaskSource=]</td><td>Yes</td></tr>
<tr><td>[=database-access-task-source=]</td><td>Yes</td></tr>
<tr><td>[=presentation-task-source=]</td><td>Yes</td></tr>
<tr><td>[=sensor-task-source=]</td><td>Yes</td></tr>
<tr><td>[=performance-timeline-task-source=]</td><td>Yes</td></tr>
<tr><td>[=web-gl-task-source=]</td><td>Yes</td></tr>
<tr><td>[=idle-task-task-source=]</td><td>Yes</td></tr>
<tr><td>[=font-loading-task-source=]</td><td>Yes</td></tr>
<tr><td>[=application-life-cycle-task-source=]</td><td>Yes</td></tr>
<tr><td>[=background-fetch-task-source=]</td><td>Yes</td></tr>
<tr><td>[=permission-task-source=]</td><td>Yes</td></tr>
<tr><td>[=client-message-queue-task-source=]</td><td>Yes</td></tr>
</table>

NOTE: networking task source is freezable with an exception: when a pending fetch keep-alive request in inflight, then networking task source must not be frozen.

Examples of [=task source/unfreezable=] task sources are:

* V8 task sources for garbage collection
* IPC task sources needed to communicate with browser process
* other task sources that are shared with the entire process 

TODO(panicker): Add note about keeping everything within a site instance that are scriptable (eg. documents that can post-message with each other) in the same lifecycle state.


### HTML: <a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#unloading-documents">Unloading documents</a> and <a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#history-traversal">History Traversal</a> ### {#html-bfcache-dfn}

When documents move into and out of <a href="https://webkit.org/blog/427/webkit-page-cache-i-the-basics/">bfcache (back forward cache)</a> they will transition its [=Document/frozenness=] state to <code>true</code> and <code>false</code> respectively.

* In the [=unload a document=] algorithm, after Step #5, if the {{PageTransitionEvent/persisted}} attribute is true (i.e. we are moving to bfcache), run the [[#change-frozenness-of-document]] algorithm, passing in |document| and <code>true</code>.
* In the [=traverse the history=] algorithm, before Step #4.6.4, if the {{PageTransitionEvent/persisted}} attribute is true (i.e. we are moving out of bfcache), run the [[#change-frozenness-of-document]] algorithm, passing in |document| and <code>false</code>.


### HTML: <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model">HTML Event Loop Processing Model</a> ### {#html-event-loop}

Step #1 currently ignores "tasks whose associated {{Document}}s are not [=fully active=]". Modify this clause to also ignore [=task source/freezable=] tasks whose associated {{Document}} is in the [=/frozen=] state.

After Step #11 during the [=Update the rendering=] add the following step.

For each [=fully active=] {{Document}} |doc| in |docs|, run the [=update document frozenness steps=] given |doc|.

### HTML: <a href="https://html.spec.whatwg.org/multipage/window-object.html#a-browsing-context-is-discarded">Discarding browsing context</a> ### {#html-discarding}

Rename the "<a href="https://html.spec.whatwg.org/multipage/window-object.html#a-browsing-context-is-discarded">discard</a>" concept, for both browsing contexts and documents, to "destroy". This allows us to use the "discarded" terminology for the user-facing {{Document/wasDiscarded}} attribute.

### HTML: Modifications to <a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#initialise-the-document-object">Initialize the document</a> ### {#html-initialize-doc}

Before Step #3 add following:

If the browsing context was previously [=/discarded=], then set the {{Document}}'s [=Document/discarded=] boolean to true.

### HTML: Modifications to [=iframe load event steps=] ### {#html-iframe-load}

After Step #5 add following:

Run the [=update document frozenness steps=] given |child document|.

### HTML: Modifications to [=media-elements=]

Each HTMLMediaElement has a <dfn for="HTMLMediaElement">resume frozen flag</dfn>, which is initially set to false.

Additions to Page Lifecycle spec {#page-lifecycle}
--------------------------------------------

<h4>FROZENNESS state</h4>
A document can be in one of the following <dfn for="Document">FROZENNESS</dfn> states:

* true: the document is <dfn export lt="frozen">frozen</dfn>, any freezeable tasks associated with the document will not run
* false: the document is <dfn export lt="unfrozen">unfrozen</dfn>, tasks associated with the document will run as usual

    NOTE: Per the [[#change-frozenness-of-a-top-level-document]] algorithm, when the Document of the top level browsing context changes its [=Document/frozenness=] state then all documents of descendant browsing contexts will also change [=Document/frozenness=] to the same value (and be consistent with the Document of the top level browsing context).

The UA may choose to execute [[#change-frozenness-of-a-top-level-document]] with <code>true</code> in certain situations.
For instance, if a top level browsing context is in the background or hidden, and a grace period has elapsed the UA could execute [[#change-frozenness-of-a-top-level-document]] with <code>true</code> to conserve resources and maintain the quality of the (foreground) user experience.
Specific examples:

* In mobile Chrome, tabs that have been in background for (at least) 5 minutes, may be [=/frozen=], to conserve battery and data.
* In desktop Chrome, background tabs that are not important to the user (not used in some time) may be [=/discarded=], to conserve memory

    NOTE: background tabs that are actively doing work on behalf of the user (eg. playing audio) are generally not [=/frozen=] or [=/discarded=].

    NOTE: For a detailed list of heuristics & exclusions used by Chrome, see <a href=https://docs.google.com/document/d/1QJpuBTdllLVflMJSov0tlFX3e3yfSfd_-al2IBavbQM/edit>this doc</a>. 
    
The UA will typically execute [[#change-frozenness-of-a-top-level-document]] with <code>false</code> when the user revisits that browsing context. In addition, the UA may choose to periodically execute [[#change-frozenness-of-a-top-level-document]] with <code>false</code> in the background, if plentiful resources are available.

<h4>Change frozenness of a top-level document</h4>
To change the [=Document/frozenness=] of a top-level document passing in a document |doc| and [=Document/frozenness=] state |x| (one of <code>true</code>, <code>false</code>):

1. Assert: |doc|'s [=Document/browsing context=] is a [=top-level browsing context=].
1. Execute [[#change-frozenness-of-document]] passing in |doc|, |x|, and <code>false</code> for |auto resume media flag|.
1. Let |descendants| be the [=list of the descendant browsing contexts=] of |doc|.
1. For each [=/browsing context=] |b| in |descendants|:
    1. Let |d| be the [=active document=] of |b|.
    1. Execute [[#change-frozenness-of-document]] passing in |d|, |x|, and <code>false</code> for |auto resume media flag|.

<h4 dfn>Change frozenness of document</h4>
To change the [=Document/frozenness=] of a document given a document |doc|, [=Document/frozenness=] state |x| and
|auto resume frozen media| (one of <code>true</code>, <code>false</code>):
1. If |x| is true:
    1. Run the [=freeze steps=] given |doc| and |auto resume media flag|.
1. Otherwise:
    1. Run the [=resume steps=] given |doc|.

To run the <dfn export>freeze steps</dfn> for a {{Document}} <var>doc</var>,
and |auto resume frozen media| (one of <code>true</code>, <code>false</code>)
run the following steps:
1. Set |doc|'s [=Document/frozenness=] state to <code>true</code>.
1. [=Fire an event=] named <code>freeze</code> at |doc|.
1. Let |elements| be all [=media elements=] in [=tree order=]
1. For each |element| in |elements|.
    1. If |element|'s {{HTMLMediaElement/paused}} is false.
        1. Set |element|'s [=HTMLMediaElement/resume frozen flag=] to |auto resume frozen media|.
        1. Call |element|'s {{HTMLMediaElement/pause}} method.

    NOTE: it is intentional that the ordering between the assignment of the of frozneness state
    occurs first before event firing.

To run the <dfn export>resume steps</dfn> for a {{Document}} <var>doc</var>,
run the following steps:
1. Let |elements| be all [=media elements=] in [=tree order=]
    1. For each |element| in |elements|.
    1. If |elements|'s [=HTMLMediaElement/resume frozen flag=] is <code>true</code>.
        1. Set |elements|'s [=HTMLMediaElement/resume frozen flag=] to <code>false</code>.
        1. Call |element|'s {{HTMLMediaElement/play}} method.
1. [=Fire an event=] named <code>resume</code> at |doc|.
1. Set |doc|'s [=Document/frozenness=] state to <code>false</code>.

    NOTE: it is intentional that the ordering between the assignment of the of frozneness state
    comes last after event firing.

<h4>Discarding</h4>
Each Document has a <dfn for="Document">discarded</dfn> boolean, which is initially false.

To <dfn export lt="discarded|discard">discard</dfn> a browsing context, <a href="https://html.spec.whatwg.org/multipage/window-object.html#a-browsing-context-is-discarded">destroy the browsing context</a>, and make note of the fact that the reason it and any descendant browsing contents were destroyed was because of discarding.

    NOTE: [=Discard=] is typically done to reclaim system memory, when memory and other resources are running low. On the other hand destroying a browser context is the normal teardown due to user leaving the page etc.

Browsing contexts -- that are in the background and have their documents in <a href="https://www.w3.org/TR/page-visibility-2/#visibility-states-and-the-visibilitystate-enum">VisibilityState hidden</a> -- can be [=/discarded=], under resource pressure (eg. low memory). Specific example:

* In desktop Chrome, background tabs that are not important to the user (not used in some time) may be [=/discarded=], to conserve memory

    NOTE: background tabs that are actively doing work on behalf of the user (eg. playing audio) are generally not [=/discarded=].

    NOTE: For a detailed list of heuristics & exclusions used by Chrome, see <a href=https://docs.google.com/document/d/1QJpuBTdllLVflMJSov0tlFX3e3yfSfd_-al2IBavbQM/edit>this doc</a>. 

When a [=top-level browsing context=] (tab in the browser) is [=/discarded=] due to resource pressure (or unexpected events eg. process crash), and later the user revisits the tab in the browser, then the {{Document}}'s [=Document/discarded=] boolean will be true due to [[#html-initialize-doc]].


<!-- ============================================================ -->
<h2 id=acknowledgements>Acknowledgements</h2>
<!-- ============================================================ -->

Special thanks to Ojan Vafai, Philip Walton, Fadi Meawad, Olli Pettay, Todd Reifsteck for their technical input and suggestions that led to improvements to this specification.
